// Copyright 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "exegesis/x86/instruction_encoding.h"

#include <algorithm>
#include <cstdint>
#include <initializer_list>
#include <iterator>
#include <memory>
#include <numeric>
#include <type_traits>
#include <unordered_map>
#include <utility>
#include <vector>

#include "absl/algorithm/container.h"
#include "absl/container/flat_hash_map.h"
#include "absl/memory/memory.h"
#include "absl/strings/ascii.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "exegesis/util/bits.h"
#include "exegesis/util/category_util.h"
#include "exegesis/util/instruction_syntax.h"
#include "exegesis/x86/encoding_specification.h"
#include "glog/logging.h"
#include "src/google/protobuf/repeated_field.h"
#include "util/gtl/map_util.h"
#include "util/task/canonical_errors.h"
#include "util/task/statusor.h"

namespace exegesis {
namespace x86 {
namespace {

using ::exegesis::util::FailedPreconditionError;
using ::exegesis::util::InvalidArgumentError;
using ::exegesis::util::OkStatus;
using ::exegesis::util::Status;
using ::google::protobuf::RepeatedField;

}  // namespace

int NumModRmDisplacementBytes(const ModRm& modrm, const Sib& sib) {
  switch (modrm.addressing_mode()) {
    case ModRm::INDIRECT:
      // There are three possibilities: either modrm.rm is 5, and then the
      // address is RIP + 32-bit displacement, or modrm.rm is 4 and then there
      // is a 32-bit displacement if sib.base is 5.
      return (modrm.rm_operand() == 5 ||
              (modrm.rm_operand() == 4 && sib.base() == 5))
                 ? 4
                 : 0;
    case ModRm::INDIRECT_WITH_8_BIT_DISPLACEMENT:
      return 1;
    case ModRm::INDIRECT_WITH_32_BIT_DISPLACEMENT:
      return 4;
    default:
      // Covers ModRm::DIRECT and the boundary values generated by the proto
      // compiler.
      return 0;
  }
}

bool ModRmRequiresSib(const ModRm& modrm) {
  return modrm.addressing_mode() != ModRm::DIRECT && modrm.rm_operand() == 4;
}

InstructionOperand::AddressingMode ConvertToInstructionOperandAddressingMode(
    const DecodedInstruction& decoded_instruction) {
  DCHECK(decoded_instruction.has_modrm());

  const ModRm::AddressingMode modrm_addressing_mode =
      decoded_instruction.modrm().addressing_mode();
  const bool has_sib = decoded_instruction.modrm().rm_operand() == 0x04;
  DCHECK(modrm_addressing_mode == ModRm::DIRECT || !has_sib ||
         decoded_instruction.has_sib())
      << "Sib structure missing:" << decoded_instruction.DebugString();

  switch (modrm_addressing_mode) {
    case ModRm::INDIRECT:
      if (!has_sib) {
        if (decoded_instruction.modrm().rm_operand() == 0x05) {
          return InstructionOperand::
              INDIRECT_ADDRESSING_WITH_INSTRUCTION_POINTER;
        }
        return InstructionOperand::INDIRECT_ADDRESSING;
      } else {
        const Sib& sib = decoded_instruction.sib();
        if (sib.index() == 0x04) {
          if (sib.base() == 0x05) {
            return InstructionOperand::INDIRECT_ADDRESSING_WITH_DISPLACEMENT;
          }
          return InstructionOperand::INDIRECT_ADDRESSING_WITH_BASE;
        } else if (sib.base() == 0x05) {
          return InstructionOperand::
              INDIRECT_ADDRESSING_WITH_INDEX_AND_DISPLACEMENT;
        } else {
          return InstructionOperand::INDIRECT_ADDRESSING_WITH_BASE_AND_INDEX;
        }
      }
    case ModRm::INDIRECT_WITH_8_BIT_DISPLACEMENT:
    case ModRm::INDIRECT_WITH_32_BIT_DISPLACEMENT:
      if (!has_sib) {
        return InstructionOperand::
            INDIRECT_ADDRESSING_WITH_BASE_AND_DISPLACEMENT;
      } else {
        const Sib& sib = decoded_instruction.sib();
        if (sib.index() == 0x04) {
          return InstructionOperand::
              INDIRECT_ADDRESSING_WITH_BASE_AND_DISPLACEMENT;
        }
        return InstructionOperand::
            INDIRECT_ADDRESSING_WITH_BASE_DISPLACEMENT_AND_INDEX;
      }
    case ModRm::DIRECT:
      return InstructionOperand::DIRECT_ADDRESSING;
    default:
      LOG(FATAL) << "Unexpected addressing mode!";
  }
}

namespace {

Status InvalidEvexVectorLengthError(uint32_t expected_evex_ll_bits,
                                    uint32_t actual_evex_ll_bits) {
  return InvalidArgumentError(
      absl::StrCat("The instruction encoding specification prescribes that the "
                   "vector length bits are set to ",
                   expected_evex_ll_bits, ", but the actual value is ",
                   actual_evex_ll_bits));
}

}  // namespace

Status ValidateVectorSizeBits(VexVectorSize vector_size_specification,
                              uint32_t vector_length_or_rounding_bits,
                              VexPrefixType prefix_type) {
  switch (vector_size_specification) {
    case VEX_VECTOR_SIZE_IS_IGNORED:
    case VEX_VECTOR_SIZE_BIT_IS_ZERO:
    case VEX_VECTOR_SIZE_128_BIT:
      if (vector_length_or_rounding_bits !=
          kEvexPrefixVectorLength128BitsOrZero) {
        return InvalidEvexVectorLengthError(
            kEvexPrefixVectorLength128BitsOrZero,
            vector_length_or_rounding_bits);
      }
      break;
    case VEX_VECTOR_SIZE_BIT_IS_ONE:
    case VEX_VECTOR_SIZE_256_BIT:
      if (vector_length_or_rounding_bits !=
          kEvexPrefixVectorLength256BitsOrOne) {
        return InvalidEvexVectorLengthError(kEvexPrefixVectorLength256BitsOrOne,
                                            vector_length_or_rounding_bits);
      }
      break;
    case VEX_VECTOR_SIZE_512_BIT:
      if (prefix_type != EVEX_PREFIX) {
        return FailedPreconditionError(
            "The 512-bit vector length is not supported by the VEX prefix.");
      }
      if (vector_length_or_rounding_bits != kEvexPrefixVectorLength512Bits) {
        return InvalidEvexVectorLengthError(kEvexPrefixVectorLength512Bits,
                                            vector_length_or_rounding_bits);
      }
      break;
    default:
      // All "real" values must be handled by one of the cases above. However,
      // we still need to keep the default case, because the proto compiler adds
      // sentinel values that force the type of the enum to be int32_t but that
      // do not have any real meaning.
      return FailedPreconditionError(
          absl::StrCat("Unexpected value of the vector length in the encoding "
                       "specification: ",
                       vector_size_specification));
  }
  return OkStatus();
}

Status ValidateVexWBit(VexPrefixEncodingSpecification::VexWUsage vex_w_usage,
                       bool vex_w_bit) {
  switch (vex_w_usage) {
    case VexPrefixEncodingSpecification::VEX_W_IS_ZERO:
      if (vex_w_bit) {
        return InvalidArgumentError(
            "The instruction specification prescribes that the vex.w bit is "
            "set to zero but the instruction sets it to one.");
      }
      break;
    case VexPrefixEncodingSpecification::VEX_W_IS_ONE:
      if (!vex_w_bit) {
        return InvalidArgumentError(
            "The instruction specification prescribes that the vex.w bit is "
            "set to one but the instruction sets it to zero.");
      }
      break;
    case VexPrefixEncodingSpecification::VEX_W_IS_IGNORED:
      // The value of VEX.w is ignored; accept any value of the bit.
      break;
    default:
      // All "real" values must be handled by one of the cases above. However,
      // we still need to keep the default case, because the proto compiler adds
      // sentinel values that force the type of the enum to be int32_t but that
      // do not have any real meaning.
      return FailedPreconditionError(absl::StrCat(
          "Unexpected value of the VEX.w bit in the encoding specification: ",
          vex_w_usage));
  }
  return OkStatus();
}

Status ValidateEvexBBit(const VexPrefixEncodingSpecification& vex_specification,
                        const DecodedInstruction& decoded_instruction) {
  if (vex_specification.prefix_type() != EVEX_PREFIX) {
    return FailedPreconditionError("The prefix is not an EVEX prefix.");
  }
  const bool evex_b_bit =
      decoded_instruction.evex_prefix().broadcast_or_control();
  const EvexBInterpretation used_interpretation =
      GetUsedEvexBInterpretation(vex_specification, decoded_instruction);
  // When used_interpretation is UNDEFINED_EVEX_B_INTERPRETATION, it means
  // that the combination of 'specification' and 'decoded_instruction' does not
  // use the EVEX.b bit, and it must be set to 0. In all other cases, we allow
  // both values.
  if (used_interpretation == UNDEFINED_EVEX_B_INTERPRETATION && evex_b_bit) {
    // Either the instruction does not use the EVEX.b bit at all or the only
    // interpretation allowed by vex_specification is a broadcast, and
    // decoded_instruction uses direct addressing. In both cases the EVEX.b bit
    // must be set to zero.
    return InvalidArgumentError(
        "The instance of the instruction does not use the EVEX.b bit.");
  }
  return OkStatus();
}

EvexBInterpretation GetUsedEvexBInterpretation(
    const VexPrefixEncodingSpecification& vex_specification,
    const DecodedInstruction& decoded_instruction) {
  if (vex_specification.prefix_type() != EVEX_PREFIX) {
    return UNDEFINED_EVEX_B_INTERPRETATION;
  }
  const bool has_memory_operand =
      decoded_instruction.has_modrm() &&
      decoded_instruction.modrm().addressing_mode() != ModRm::DIRECT;
  switch (vex_specification.evex_b_interpretations_size()) {
    case 0:
      // The EVEX.b bit is not used by the instruction.
      return UNDEFINED_EVEX_B_INTERPRETATION;
    case 1: {
      // There is only one possible interpretation. If it is a broadcast, we
      // also need to check the addressing mode of the operand; otherwise, just
      // return the interpretation.
      const EvexBInterpretation interpretation =
          vex_specification.evex_b_interpretations(0);
      return IsEvexBBroadcast(interpretation) && !has_memory_operand
                 ? UNDEFINED_EVEX_B_INTERPRETATION
                 : interpretation;
    }
    case 2: {
      // There are two interpretations. Because of mutual exclusivity of some
      // interpretations, there is always one broadcast, and either static
      // rounding or suppress all exceptions. The matcher selects the right
      // interpretation depending on the addressing mode of the instruction.
      const auto matcher = [has_memory_operand](int interpretation) {
        return has_memory_operand ==
               IsEvexBBroadcast(
                   static_cast<EvexBInterpretation>(interpretation));
      };
      const RepeatedField<int>& interpretations =
          vex_specification.evex_b_interpretations();
      const auto used_interpretation =
          std::find_if(interpretations.begin(), interpretations.end(), matcher);
      // With the allowed combinations of interpretations, there must always be
      // a match; if not, it means that the encoding specification is invalid.
      CHECK_NE(used_interpretation, interpretations.end());
      return static_cast<EvexBInterpretation>(*used_interpretation);
    }
    default:
      // There may be at most two different EVEX.b interpretations; see the
      // comment on VexPrefixEncodingSpecification.evex_b_interpretations for
      // more details.
      LOG(FATAL) << "There may be at most two EVEX.b interpretations.";
      return UNDEFINED_EVEX_B_INTERPRETATION;
  }
}

Status ValidateEvexOpmask(
    const VexPrefixEncodingSpecification& vex_specification,
    const DecodedInstruction& decoded_instruction) {
  if (vex_specification.prefix_type() != EVEX_PREFIX) {
    return FailedPreconditionError(
        "The instruction does not use the EVEX prefix.");
  }
  const EvexPrefix& evex = decoded_instruction.evex_prefix();
  // Validate the EVEX.aaa bits.
  switch (vex_specification.opmask_usage()) {
    case EVEX_OPMASK_IS_NOT_USED:
      // The opmask is not used. All of EVEX.aaa and EVEX.z must be set to zero.
      if (evex.opmask_register() != 0) {
        return InvalidArgumentError(
            "The instruction does not support opmasks.");
      }
      break;
    case EVEX_OPMASK_IS_OPTIONAL:
      // Any value of EVEX.aaa is allowed here.
      break;
    case EVEX_OPMASK_IS_REQUIRED:
      if (evex.opmask_register() == 0) {
        return InvalidArgumentError(
            "The instruction does not allow using k0 as opmask register.");
      }
      break;
    default:
      // All other cases are the support values generated by the proto compiler,
      // e.g. the lower and the upper bounds of the enum. They should never
      // occur in real data.
      LOG(FATAL) << "Invalid vex_specification.opmask_usage() value.";
      return FailedPreconditionError(
          "Invalid vex_specification.opmask_usage() value.");
  }
  // Validate the EVEX.z bit.
  if (evex.z() && vex_specification.masking_operation() !=
                      EVEX_MASKING_MERGING_AND_ZEROING) {
    return InvalidArgumentError(
        "The instruction does not support zeroing or it does not support "
        "masking at all.");
  }
  return OkStatus();
}

Status ValidateVexRegisterOperandBits(
    const VexPrefixEncodingSpecification& vex_prefix_specification,
    uint32_t vex_register_operand) {
  // A convenience shortcut: 0 is the default value of inverted_register_operand
  // in the proto; allowing it even when the register is not used and accounting
  // for it in the encoder makes all test cases that do not use the register
  // operand shorter and easier to read.
  if (vex_register_operand == 0) return OkStatus();
  // Both VEX and EVEX contain the prefix in 1's complement, and when it's not
  // used, all the bits must be set to 1. However, the EVEX prefix uses 5 bits
  // for encoding registers, while the VEX prefix uses only 4 bits, thus the
  // value in this case is different for each prefix.
  const bool operand_is_used =
      vex_prefix_specification.vex_operand_usage() != VEX_OPERAND_IS_NOT_USED;
  const int max_value =
      vex_prefix_specification.prefix_type() == VEX_PREFIX ? 15 : 31;
  const int min_value = operand_is_used ? 0 : max_value;
  if (vex_register_operand < min_value || vex_register_operand > max_value) {
    return InvalidArgumentError(absl::StrCat(
        "Invalid VEX/EVEX prefix operand index: ", vex_register_operand));
  }
  return OkStatus();
}

namespace {

VexPrefix BaseVexPrefix(const VexPrefixEncodingSpecification& specification) {
  VexPrefix prefix;
  prefix.set_mandatory_prefix(specification.mandatory_prefix());
  prefix.set_map_select(specification.map_select());
  prefix.set_not_b(true);
  prefix.set_not_r(true);
  prefix.set_not_x(true);
  prefix.set_w(specification.vex_w_usage() ==
               VexPrefixEncodingSpecification::VEX_W_IS_ONE);
  prefix.set_use_256_bit_vector_length(specification.vector_size() ==
                                       VEX_VECTOR_SIZE_256_BIT);
  return prefix;
}

LegacyPrefixes BaseLegacyPrefixes(
    const LegacyPrefixEncodingSpecification& specification) {
  LegacyPrefixes prefix;
  if (specification.operand_size_override_prefix() ==
      LegacyEncoding::PREFIX_IS_REQUIRED) {
    prefix.set_operand_size_override(LegacyEncoding::OPERAND_SIZE_OVERRIDE);
  }
  if (specification.rex_w_prefix() == LegacyEncoding::PREFIX_IS_REQUIRED) {
    prefix.mutable_rex()->set_w(true);
  }
  if (specification.has_mandatory_repe_prefix()) {
    prefix.set_lock_or_rep(LegacyEncoding::REP_PREFIX);
  }
  if (specification.has_mandatory_repne_prefix()) {
    prefix.set_lock_or_rep(LegacyEncoding::REPNE_PREFIX);
  }
  return prefix;
}
}  // namespace

DecodedInstruction BaseDecodedInstruction(
    const EncodingSpecification& specification) {
  DecodedInstruction decoded_instruction;
  decoded_instruction.set_opcode(specification.opcode());
  switch (specification.modrm_usage()) {
    case EncodingSpecification::FULL_MODRM:
      // We call mutable_modrm to add the submessage to the proto. There aren't
      // any non-default values in specification.modrm that we would have to
      // change right now.
      decoded_instruction.mutable_modrm();
      break;
    case EncodingSpecification::OPCODE_EXTENSION_IN_MODRM:
      decoded_instruction.mutable_modrm()->set_register_operand(
          specification.modrm_opcode_extension());
      break;
    default:
      break;
  }

  if (specification.has_vex_prefix()) {
    *decoded_instruction.mutable_vex_prefix() =
        BaseVexPrefix(specification.vex_prefix());
  } else {
    *decoded_instruction.mutable_legacy_prefixes() =
        BaseLegacyPrefixes(specification.legacy_prefixes());
  }

  return decoded_instruction;
}

namespace {
// Constants with the indices of the registers we're using in the generated
// encodings. Most of them are chosen arbitrarily, and our main goal was to use
// as many different values as possible, to make debugging the generated values
// easier.
//
// The value used for the modrm.rm operand.
const uint32_t kRmOperand = 3;

// When this value is used for modrm.rm in INDIRECT addressing mode, switches to
// RIP-relative addressing with a 32-bit displacement. The register ESP/RSP is
// not used.
const uint32_t kRmRipEscape = 5;

// When this value is used for modrm.rm in any of the indirect addressing modes,
// it means that the ModR/M byte is followed by a SIB byte, and the actual
// address is specified there.
const uint32_t kRmSibEscape = 4;

// The value used for sib.scale (if present).
const uint32_t kScale = 2;

// When this value is used for sib.base in the INDIRECT addressing mode to
// specify that there is a 32-bit displacement added to the address specified
// by the SIB byte.
const uint32_t kSibDisplacementEscape = 5;

// The value used for sib.index (if present).
const uint32_t kIndexRegister = 1;

// The value used for sib.base (if present).
const uint32_t kBaseRegister = 4;

// The value of the 8-bit displacement.
const uint32_t k8BitDisplacement = 127;

// The value of the 32-bit displacement.
const uint32_t k32BitDisplacement = 0x12345678;

// Finds an operand of the instruction that has the given encoding. Returns
// nullptr if no such operand is found.
const InstructionOperand* GetOperandWithEncoding(
    const InstructionProto& instruction,
    InstructionOperand::Encoding encoding) {
  for (const InstructionFormat& vendor_syntax : instruction.vendor_syntax()) {
    const auto operand =
        absl::c_find_if(vendor_syntax.operands(),
                        [encoding](const InstructionOperand& operand) {
                          return operand.encoding() == encoding;
                        });
    if (operand != vendor_syntax.operands().end()) return &(*operand);
  }
  return nullptr;
}

// The following functions decide whether 'instruction' uses a certain encoding
// for one of its operands. The first function is a generic version, the
// following three check for the presence of an operand in a concrete location.
bool HasOperandWithEncoding(const InstructionProto& instruction,
                            InstructionOperand::Encoding encoding) {
  return GetOperandWithEncoding(instruction, encoding) != nullptr;
}

bool HasModRmRmOperand(const InstructionProto& instruction) {
  return HasOperandWithEncoding(instruction,
                                InstructionOperand::MODRM_RM_ENCODING);
}

bool HasModRmRegOperand(const InstructionProto& instruction) {
  return HasOperandWithEncoding(instruction,
                                InstructionOperand::MODRM_REG_ENCODING);
}

bool HasVexPrefixOperand(const InstructionProto& instruction) {
  return HasOperandWithEncoding(instruction,
                                InstructionOperand::VEX_V_ENCODING);
}

// Creates a Sib structure with example values.
Sib MakeExampleSib() {
  Sib sib;
  sib.set_base(kBaseRegister);
  sib.set_index(kIndexRegister);
  sib.set_scale(kScale);
  return sib;
}

// Generates examples of the ModR/M and SIB bytes with the INDIRECT addressing
// (modrm.mod == 0). This function covers four basic cases:
// - indirect addressing with a base register,
// - indirect addressing relative to RIP, with a 32-bit displacement,
// - indirect addressing with ModR/M and SIB,
// - indirect addressing with ModR/M, SIB and a 32-bit displacement.
void GenerateModRmIndirectEncodingExamples(
    const DecodedInstruction& decoded_instruction_base,
    std::vector<DecodedInstruction>* examples) {
  CHECK(examples != nullptr);
  {
    // Indirect addressing with a base register (encoded only using the ModR/M
    // byte).
    DecodedInstruction decoded_instruction = decoded_instruction_base;
    ModRm* const modrm = decoded_instruction.mutable_modrm();
    modrm->set_rm_operand(kRmOperand);
    examples->push_back(decoded_instruction);
  }

  {
    // RIP-relative addressing with a 32-bit displacement, encoded using the
    // ModR/M byte and the displacement.
    DecodedInstruction decoded_instruction = decoded_instruction_base;
    ModRm* const modrm = decoded_instruction.mutable_modrm();
    modrm->set_rm_operand(kRmRipEscape);
    modrm->set_address_displacement(k32BitDisplacement);
    examples->push_back(decoded_instruction);
  }

  DecodedInstruction decoded_instruction_sib = decoded_instruction_base;
  decoded_instruction_sib.mutable_modrm()->set_rm_operand(kRmSibEscape);

  {
    // Indirect addressing with base and index, encoded using the ModR/M and SIB
    // bytes.
    DecodedInstruction decoded_instruction = decoded_instruction_sib;
    *decoded_instruction.mutable_sib() = MakeExampleSib();
    examples->push_back(decoded_instruction);
  }

  {
    // Indirect addressing with base, index and 32-bit displacement, encoded
    // using the ModR/M and SIB bytes and the displacement.
    DecodedInstruction decoded_instruction = decoded_instruction_sib;
    Sib* const sib = decoded_instruction.mutable_sib();
    sib->set_base(kSibDisplacementEscape);
    sib->set_index(kIndexRegister);
    sib->set_scale(kScale);
    decoded_instruction.mutable_modrm()->set_address_displacement(
        k32BitDisplacement);
    examples->push_back(decoded_instruction);
  }
  // NOTE(ondrasej): This covers all combinations of the presence of
  // ModR/M, SIB and displacement, but it does not cover all possible
  // addressing modes with ModRm::INDIRECT. There are still more, e.g. the
  // displacement-only addressing mode, and some combinations encodings
  // with an index. However, these encodings should not differ in encoding size,
  // micro-operations generated for the instruction or the overall performance.
}

// Generates examples of the ModR/M and SIB bytes with the
// INDIRECT_WITH_*_BIT_DISPLACEMENT addressing (modrm.mod == 1 or 2). The
// function covers the case with and without the SIB byte.
void GenerateModRmIndirectEncodingWithDisplacementExamples(
    const DecodedInstruction& decoded_instruction_base,
    const uint32_t displacement, std::vector<DecodedInstruction>* examples) {
  CHECK(examples != nullptr);
  // ModR/M encoding using only the ModR/M byte.
  DecodedInstruction decoded_instruction = decoded_instruction_base;
  ModRm* const modrm = decoded_instruction.mutable_modrm();
  modrm->set_rm_operand(kRmOperand);
  modrm->set_address_displacement(displacement);
  examples->push_back(decoded_instruction);

  // ModR/M encoding using the ModR/M and SIB bytes.
  modrm->set_rm_operand(kRmSibEscape);
  *decoded_instruction.mutable_sib() = MakeExampleSib();
  examples->push_back(decoded_instruction);
}

// Generates the list of possible contents of the ModR/M and eventually SIB
// bytes using the given instruction encoding specification and the
// specification of the modrm.rm operand. Note that the modrm.rm operand is the
// only one that allows some flexibility - modrm.reg always uses direct
// addressing, and the only effect it can have on an instruction is when the
// extension bit in the REX or three-byte VEX prefix. However, this is covered
// by the function AppendPrefixVariations.
std::vector<DecodedInstruction> GenerateModRMEncodingExamples(
    const EncodingSpecification& specification,
    const InstructionProto& instruction,
    DecodedInstruction decoded_instruction_base) {
  // Find the ModR/M operand, to determine which addressing modes are allowed.
  const InstructionOperand* const modrm_operand = GetOperandWithEncoding(
      instruction, InstructionOperand::MODRM_RM_ENCODING);
  CHECK(modrm_operand != nullptr);
  constexpr ModRm::AddressingMode kAllowedAddressingModes[] = {
      ModRm::DIRECT, ModRm::INDIRECT_WITH_8_BIT_DISPLACEMENT,
      ModRm::INDIRECT_WITH_32_BIT_DISPLACEMENT, ModRm::INDIRECT};
  constexpr ModRm::AddressingMode kIndirectAddressingModes[] = {
      ModRm::INDIRECT_WITH_8_BIT_DISPLACEMENT,
      ModRm::INDIRECT_WITH_32_BIT_DISPLACEMENT, ModRm::INDIRECT};

  // Get the list of ModR/M addressing modes from the generic categories.
  std::vector<DecodedInstruction> examples;
  std::vector<ModRm::AddressingMode> addressing_modes;
  switch (modrm_operand->addressing_mode()) {
    case InstructionOperand::ANY_ADDRESSING_WITH_FLEXIBLE_REGISTERS:
      addressing_modes.assign(std::begin(kAllowedAddressingModes),
                              std::end(kAllowedAddressingModes));
      break;
    case InstructionOperand::DIRECT_ADDRESSING:
      addressing_modes.push_back(ModRm::DIRECT);
      break;
    case InstructionOperand::INDIRECT_ADDRESSING:
      addressing_modes.assign(std::begin(kIndirectAddressingModes),
                              std::end(kIndirectAddressingModes));
      break;
    case InstructionOperand::INDIRECT_ADDRESSING_WITH_BASE_AND_DISPLACEMENT:
    case InstructionOperand::
        INDIRECT_ADDRESSING_WITH_BASE_DISPLACEMENT_AND_INDEX:
      addressing_modes.push_back(ModRm::INDIRECT_WITH_8_BIT_DISPLACEMENT);
      addressing_modes.push_back(ModRm::INDIRECT_WITH_32_BIT_DISPLACEMENT);
      break;
    default:
      LOG(FATAL) << "Unexpected addressing mode: "
                 << InstructionOperand::AddressingMode_Name(
                        modrm_operand->addressing_mode());
  }

  // Generate examples for all selected addressing modes.
  for (const ModRm::AddressingMode addressing_mode : addressing_modes) {
    ModRm* const modrm_base = decoded_instruction_base.mutable_modrm();
    modrm_base->set_addressing_mode(addressing_mode);
    switch (addressing_mode) {
      case ModRm::INDIRECT:
        GenerateModRmIndirectEncodingExamples(decoded_instruction_base,
                                              &examples);
        break;
      case ModRm::INDIRECT_WITH_8_BIT_DISPLACEMENT:
        GenerateModRmIndirectEncodingWithDisplacementExamples(
            decoded_instruction_base, k8BitDisplacement, &examples);
        break;
      case ModRm::INDIRECT_WITH_32_BIT_DISPLACEMENT:
        GenerateModRmIndirectEncodingWithDisplacementExamples(
            decoded_instruction_base, k32BitDisplacement, &examples);
        break;
      case ModRm::DIRECT: {
        // ModR/M with direct encoding.
        DecodedInstruction decoded_instruction = decoded_instruction_base;
        ModRm* const modrm = decoded_instruction.mutable_modrm();
        modrm->set_rm_operand(kRmOperand);
        examples.push_back(decoded_instruction);
      } break;
      default:
        LOG(FATAL) << "Unexpected addressing mode: "
                   << ModRm_AddressingMode_Name(addressing_mode);
    }
  }
  return examples;
}

// Generates all variations of the instruction 'instruction' with base encoding
// in 'base' based on the allowed prefixes.
// NOTE(ondrasej): For now, the function supports only the REX prefix and the
// VEX prefix. We also need to add support for LOCK and REP prefixes.
void AppendPrefixVariations(const InstructionProto& instruction,
                            const EncodingSpecification& specification,
                            const DecodedInstruction& base,
                            std::vector<DecodedInstruction>* examples) {
  CHECK(examples != nullptr);
  // TODO(ondrasej): Add the LOCK prefix if the instruction supports it.
  // TODO(ondrasej): Add the REP prefix if the instruction supports it.
  // TODO(ondrasej): Add the address size override prefix if the instruction
  // supports it.

  // The following block creates additional versions of the instruction by using
  // the extended registers:
  // 1. If the instruction is a legacy instruction, it adds a version with the
  //    REX prefix by setting the rex.b bit to 1. This has no effect on encoding
  //    size for instructions that always use the REX prefix, e.g. 64-bit
  //    instructions. In such cases, we don't add any new version.
  // 2. If the instruction is a VEX instruction, it adds a version that uses the
  //    three-byte VEX prefix form, by setting the vex.not_b bit to false.
  //    Note that instructions that use an opcode map different from 0F
  //    (vex.map_select != 1) or that set the vex.w bit already must use the
  //    three-byte form. In such cases, we don't add any new version of the
  //    instruction.
  const bool has_vex_prefix = specification.has_vex_prefix();
  const bool is_three_byte_vex =
      has_vex_prefix &&
      (base.vex_prefix().map_select() != VexEncoding::MAP_SELECT_0F ||
       base.vex_prefix().w());
  const bool has_rex_prefix =
      !has_vex_prefix && base.legacy_prefixes().rex().w();
  if (!is_three_byte_vex && !has_rex_prefix) {
    if (HasModRmRmOperand(instruction) ||
        specification.operand_in_opcode() ==
            EncodingSpecification::GENERAL_PURPOSE_REGISTER_IN_OPCODE) {
      // If the instruction has a modrm.rm operand, it means that the rex.b
      // prefix (and its VEX equivalent) are extending either the register index
      // in modrm.rm, or in sib.base, and they are well defined in all cases.
      // NOTE(ondrasej): The rex.b bit is irrelevant in case of RIP-relative
      // indirect addressing, or absolute address addressing. On the other hand,
      // http://wiki.osdev.org/X86-64_Instruction_Encoding (the section on
      // ModR/M and SIB encoding) suggests that setting it to 1 should not cause
      // any harm either.
      DecodedInstruction decoded_instruction = base;
      if (has_vex_prefix) {
        VexPrefix* const vex_prefix = decoded_instruction.mutable_vex_prefix();
        vex_prefix->set_not_b(false);
      } else {
        RexPrefix* const rex_prefix =
            decoded_instruction.mutable_legacy_prefixes()->mutable_rex();
        rex_prefix->set_b(true);
      }
      examples->push_back(decoded_instruction);
    } else if (HasModRmRegOperand(instruction)) {
      // Otherwise, extend the bit of the modrm.reg operand if possible. This is
      // less safe, because modrm.reg is used for encoding control and debug
      // registers, and not all values are allowed there. On the other hand,
      // all the instructions that manipulate these special registers also use
      // modrm.rm, so the first branch should catch them.
      DecodedInstruction decoded_instruction = base;
      if (has_vex_prefix) {
        VexPrefix* const vex_prefix = decoded_instruction.mutable_vex_prefix();
        vex_prefix->set_not_r(false);
      } else {
        RexPrefix* const rex_prefix =
            decoded_instruction.mutable_legacy_prefixes()->mutable_rex();
        rex_prefix->set_r(true);
      }
      examples->push_back(decoded_instruction);
    }
  }
}
}  // namespace

std::vector<DecodedInstruction> GenerateEncodingExamples(
    const InstructionProto& instruction) {
  EncodingSpecification specification =
      ParseEncodingSpecification(instruction.raw_encoding_specification())
          .ValueOrDie();
  DecodedInstruction base = BaseDecodedInstruction(specification);
  // Setting the modrm.reg and VEX prefix operands is not really necessary - the
  // default 0's would be just fine, but we assign a different value here, to
  // make debugging the outputs easier.
  if (HasModRmRegOperand(instruction)) {
    constexpr uint32_t kModRmRegOperand = 6;
    base.mutable_modrm()->set_register_operand(kModRmRegOperand);
  }
  if (HasVexPrefixOperand(instruction)) {
    constexpr uint32_t kInvertedVexPrefixOperand = 7;
    base.mutable_vex_prefix()->set_inverted_register_operand(
        kInvertedVexPrefixOperand);
  }
  // Fill in immediate values.
  for (const uint32_t size : specification.immediate_value_bytes()) {
    // Generate the immediate values as ab ac ad ae ... (depending on their
    // size, so that we can tell where one ends and other begins).
    std::string buffer(size, ' ');
    std::iota(buffer.begin(), buffer.end(), 0xab);
    base.add_immediate_value(buffer);
  }
  // Fill in the code offset.
  const int code_offset_bytes = specification.code_offset_bytes();
  if (code_offset_bytes > 0) {
    // There is at most one code offset. For debugging reasons, it's sufficient
    // to use the same value for all its bytes.
    base.set_code_offset(std::string(code_offset_bytes, 0xc0));
  }
  // Fill the VEX suffix. Part of the byte is instruction-sepcific, so we leave
  // it empty hoping that zero is a safe value.
  if (specification.has_vex_prefix() &&
      specification.vex_prefix().has_vex_operand_suffix()) {
    base.mutable_vex_prefix()->set_vex_suffix_value(0);
  }
  std::vector<DecodedInstruction> examples;
  if (HasModRmRmOperand(instruction)) {
    examples = GenerateModRMEncodingExamples(specification, instruction, base);
  } else {
    examples.push_back(base);
  }

  const int original_num_examples = examples.size();
  for (int i = 0; i < original_num_examples; ++i) {
    // We append to the same vector from which we are reading, but this is OK
    // because AppendPrefixVariations explicitly makes a copy of the example
    // before making any modifications to the vector.
    AppendPrefixVariations(instruction, specification, examples[i], &examples);
  }

  return examples;
}

namespace {

// Verifies that the legacy prefixes match the encoding specification, i.e. that
// the presence of the operand size override and the rex.w prefix in the
// instruction are the same as in the specification.
bool LegacyPrefixesMatchSpecification(
    const LegacyPrefixEncodingSpecification& specification,
    const DecodedInstruction& instruction) {
  const LegacyPrefixes& prefixes = instruction.legacy_prefixes();
  if (!PrefixMatchesSpecification(specification.rex_w_prefix(),
                                  prefixes.rex().w())) {
    DVLOG(1) << "rex.w bit mismatch!";
    return false;
  }

  // The operand size override prefix is listed explicitly in our instruction
  // database, so here we're looking for an exact match: the prefix must be
  // either present or absent in both the instruction and the specification.
  // NOTE(ondrasej): According to the ISA specification, REX.W prefix trumps the
  // operand size override prefix. However, as of 2018-05-31, GCC emits both in
  // some instructions which confuses our parser. We skip the operand size
  // override check if the instruction also uses the REX.W prefix.
  const bool has_operand_size_override =
      prefixes.operand_size_override() == LegacyEncoding::OPERAND_SIZE_OVERRIDE;
  if (!prefixes.rex().w() &&
      !PrefixMatchesSpecification(specification.operand_size_override_prefix(),
                                  has_operand_size_override)) {
    DVLOG(1) << "Operand size override prefix mismatch!";
    return false;
  }
  // The address size override prefix is not listed explicitly in our
  // instruction database. We check that the instruction has it only if the
  // specification requires it.
  if (specification.has_mandatory_address_size_override_prefix() &&
      instruction.address_size_override() !=
          LegacyEncoding::ADDRESS_SIZE_OVERRIDE) {
    DVLOG(1) << "Address size override mismatch!";
    return false;
  }
  // Check for rep/repn prefixes.
  if (specification.has_mandatory_repe_prefix() &&
      prefixes.lock_or_rep() != LegacyEncoding::REP_PREFIX) {
    DVLOG(1) << "Rep prefix mismatch!";
    return false;
  }
  if (specification.has_mandatory_repne_prefix() &&
      prefixes.lock_or_rep() != LegacyEncoding::REPNE_PREFIX) {
    DVLOG(1) << "Repne prefix mismatch!";
    return false;
  }

  return true;
}

// Checks that the mandatory prefix and the opcode map selector of a VEX/EVEX
// prefix match their values in the encoding specification. There are two
// different protos for prefix data (though there is only one for the encoding
// specification), but many fields have the same names, data types and meaning
// in both protos; using a template allows having only one version of the code.
template <typename PrefixType>
bool MandatoryPrefixAndMapSelectMatchSpecification(
    const VexPrefixEncodingSpecification& specification,
    const PrefixType& prefix) {
  if (prefix.mandatory_prefix() != specification.mandatory_prefix()) {
    DVLOG(1) << "Mandatory prefix mismatch!";
    return false;
  }
  if (prefix.map_select() != specification.map_select()) {
    DVLOG(1) << "Opcode map selector mismatch!";
    return false;
  }
  return true;
}

// Returns true if the value of the VEX/EVEX.w bit matches the requirements from
// 'specification'.
bool VexWBitMatchesSpecification(
    const VexPrefixEncodingSpecification& specification, bool vex_w) {
  switch (specification.vex_w_usage()) {
    case VexPrefixEncodingSpecification::VEX_W_IS_ZERO:
      if (vex_w) {
        DVLOG(1) << "vex.w mismatch!";
        return false;
      }
      break;
    case VexPrefixEncodingSpecification::VEX_W_IS_ONE:
      if (!vex_w) {
        DVLOG(1) << "vex.w mismatch!";
        return false;
      }
      break;
    case VexPrefixEncodingSpecification::VEX_W_IS_IGNORED:
      // The CPU explicitly ignores the vex.w bit; compilers usually emit a zero
      // in this case, but since we're simulating the CPU rather than the
      // compiler, so we accept any value here.
      break;
    default:
      LOG(FATAL) << "Unexpected vex.w bit specification: "
                 << specification.vex_w_usage();
      break;
  }
  return true;
}

// Verifies that the VEX prefix matches the encoding specification, i.e. that
// the opcode map and the mandatory prefix are the same, and that the vex.w and
// vex.l bits match the requirements of the specification.
bool VexPrefixMatchesSpecification(
    const VexPrefixEncodingSpecification& specification,
    const VexPrefix& prefix) {
  if (!MandatoryPrefixAndMapSelectMatchSpecification(specification, prefix)) {
    return false;
  }
  if (!VexWBitMatchesSpecification(specification, prefix.w())) return false;
  switch (specification.vector_size()) {
    case VEX_VECTOR_SIZE_BIT_IS_ZERO:
    case VEX_VECTOR_SIZE_128_BIT:
      if (prefix.use_256_bit_vector_length()) {
        DVLOG(1) << "Vector size mismatch: should not be 256 bits!";
        return false;
      }
      break;
    case VEX_VECTOR_SIZE_BIT_IS_ONE:
    case VEX_VECTOR_SIZE_256_BIT:
      if (!prefix.use_256_bit_vector_length()) {
        DVLOG(1) << "Vector size mismatch: should be 256 bits!";
        return false;
      }
      break;
    case VEX_VECTOR_SIZE_IS_IGNORED:
      // The CPU explicitly ignores the vector size bit; compilers usually emit
      // a zero in this case, but since we're simulating the CPU rather than
      // the compiler, so we accept any value here.
      break;
    default:
      // The default case is needed because protoc adds "technical" entries to
      // the enum, e.g. for the number of items.
      LOG(FATAL) << "Unexpected vector size usage specification: "
                 << specification.vector_size();
      break;
  }
  return true;
}

bool EvexPrefixMatchesSpecification(
    const VexPrefixEncodingSpecification& specification,
    const EvexPrefix& prefix) {
  if (!MandatoryPrefixAndMapSelectMatchSpecification(specification, prefix)) {
    return false;
  }
  if (!VexWBitMatchesSpecification(specification, prefix.w())) return false;
  // NOTE(ondrasej): For some instructions, the interpretation of the vector
  // length bits depends on the value of the EVEX.b bit: everything is as usual
  // with EVEX.b == 0, but when EVEX.b == 1, the vector length bits encode the
  // rounding mode used by the instruction and if the instruction is a vector
  // instruction, the vector length is always 512 bits. If this is the case, the
  // value of the vector length bits does not matter in the matching.
  // TODO(ondrasej): The situation is even worse: for some instructions, the
  // interpretation of the EVEX.b bit depends on the addressing mode of the
  // modrm.rm operand. When the operand is a register, EVEX.b enables static
  // rounding, but when the operand is a memory location, EVEX.b enables
  // broadcast. As a result, EVEX.b overrides the vector length bits only when
  // the operand is a register. We need to update the code below to take this
  // into account; we also need to check all call sites to make sure that they
  // fill out the addressing mode of the modrm byte.
  const bool evex_b_overrides_vector_length =
      absl::c_linear_search(specification.evex_b_interpretations(),
                            EVEX_B_ENABLES_STATIC_ROUNDING_CONTROL);
  if (!prefix.broadcast_or_control() || !evex_b_overrides_vector_length) {
    const int vector_length_bits = prefix.vector_length_or_rounding();
    switch (specification.vector_size()) {
      case VEX_VECTOR_SIZE_IS_IGNORED:
        break;
      case VEX_VECTOR_SIZE_BIT_IS_ZERO:
      case VEX_VECTOR_SIZE_128_BIT:
        if (vector_length_bits != 0) {
          DVLOG(1) << "Vector length mismatch: should be 0!";
          return false;
        }
        break;
      case VEX_VECTOR_SIZE_BIT_IS_ONE:
      case VEX_VECTOR_SIZE_256_BIT:
        if (vector_length_bits != 1) {
          DVLOG(1) << "Vector length mismatch: should be 1!";
          return false;
        }
        break;
      case VEX_VECTOR_SIZE_512_BIT:
        if (vector_length_bits != 2) {
          DVLOG(1) << "Vector length mismatch: should be 2!";
          return false;
        }
        break;
      default:
        LOG(FATAL) << "Unexpected vector size usage specification: "
                   << specification.vector_size();
        break;
    }
  }
  return true;
}

bool AddressingModeMatchesSpecification(
    const InstructionFormat& instruction_format,
    const DecodedInstruction& decoded_instruction) {
  for (const InstructionOperand& operand : instruction_format.operands()) {
    if (operand.encoding() == InstructionOperand::MODRM_RM_ENCODING) {
      if (!ModRmAddressingModeMatchesInstructionOperandAddressingMode(
              decoded_instruction, operand.addressing_mode())) {
        DVLOG(1) << "Addressing mode mismatch!\n"
                 << "Operand: " << operand.addressing_mode() << "\nModRm: "
                 << decoded_instruction.modrm().ShortDebugString()
                 << "\nSib: " << decoded_instruction.sib().ShortDebugString();
        return false;
      }
      break;
    }
  }
  return true;
}

}  // namespace

bool ModRmAddressingModeMatchesInstructionOperandAddressingMode(
    const DecodedInstruction& decoded_instruction,
    InstructionOperand::AddressingMode rm_operand_addressing_mode) {
  CHECK(decoded_instruction.has_modrm());
  const ModRm& modrm = decoded_instruction.modrm();
  const Sib& sib = decoded_instruction.sib();
  const ModRm::AddressingMode modrm_addressing_mode =
      decoded_instruction.modrm().addressing_mode();
  switch (rm_operand_addressing_mode) {
    case InstructionOperand::ANY_ADDRESSING_MODE:
      return true;
    case InstructionOperand::DIRECT_ADDRESSING:
    case InstructionOperand::BLOCK_DIRECT_ADDRESSING:
      return modrm_addressing_mode == ModRm::DIRECT;
    case InstructionOperand::INDIRECT_ADDRESSING:
    case InstructionOperand::LOAD_EFFECTIVE_ADDRESS:
      return modrm_addressing_mode != ModRm::DIRECT;
    case InstructionOperand::INDIRECT_ADDRESSING_WITH_BASE:
      // Indirect addressing with only a base register is possible only when
      // modrm.addressing_mode == INDIRECT. All other indirect addressing modes
      // add a displacement.
      return modrm_addressing_mode == ModRm::INDIRECT &&
             // modrm.addressing_mode == INDIRECT and modrm.rm == 5 is an escape
             // value for RIP-relative addressing.
             modrm.rm_operand() != 5 &&
             // modrm.addressing_mode == INDIRECT and modrm.rm == 4 is an escape
             // value for introducing the SIB byte. With a SIB byte, indirect
             // addressing with only a base register is used only when
             // sib.index == 4 and sib.base != 5.
             (modrm.rm_operand() != 4 || (sib.index() == 4 && sib.base() != 5));
    case InstructionOperand::INDIRECT_ADDRESSING_WITH_DISPLACEMENT:
      return modrm_addressing_mode == ModRm::INDIRECT &&
             // Indirect addressing with only displacement is possible only
             // through the SIB byte.
             modrm.rm_operand() == 4 &&
             // Special escape values in SIB.
             sib.index() == 4 && sib.base() == 5;
    case InstructionOperand::INDIRECT_ADDRESSING_WITH_BASE_AND_DISPLACEMENT:
      // Indirect addressing with base + displacement is only possible through
      // the two modes below.
      return (modrm_addressing_mode ==
                  ModRm::INDIRECT_WITH_8_BIT_DISPLACEMENT ||
              modrm_addressing_mode ==
                  ModRm::INDIRECT_WITH_32_BIT_DISPLACEMENT) &&
             // When the SIB byte is used, addressing with base + displacement
             // is achieved through an escape value.
             (modrm.rm_operand() != 4 || sib.index() == 4);
    case InstructionOperand::INDIRECT_ADDRESSING_WITH_BASE_AND_INDEX:
      // The only mode that does not add a displacement.
      return modrm_addressing_mode == ModRm::INDIRECT &&
             // Indirect addressing is only possible through the SIB byte.
             modrm.rm_operand() == 4 &&
             // We need to avoid the escape values within the SIB byte.
             sib.index() != 4 && sib.base() != 5;
    case InstructionOperand::INDIRECT_ADDRESSING_WITH_INDEX_AND_DISPLACEMENT:
      // The only mode allowing this addressing mode.
      return modrm_addressing_mode == ModRm::INDIRECT &&
             // The addressing is only possible through the SIB byte.
             modrm.rm_operand() == 4 &&
             // ...with the right combination of escape values.
             sib.index() != 4 && sib.base() == 5;
    case InstructionOperand::
        INDIRECT_ADDRESSING_WITH_BASE_DISPLACEMENT_AND_INDEX:
      // This addressing mode is possible only through the two following ModR/M
      // addressing modes.
      return (modrm_addressing_mode ==
                  ModRm::INDIRECT_WITH_8_BIT_DISPLACEMENT ||
              modrm_addressing_mode ==
                  ModRm::INDIRECT_WITH_32_BIT_DISPLACEMENT) &&
             // The addressing is possible only through the SIB byte.
             modrm.rm_operand() == 4 &&
             // We need to avoid the escape values in the SIB byte.
             sib.index() != 4;
    case InstructionOperand::INDIRECT_ADDRESSING_WITH_VSIB:
      // VSIB addressing is possible in all addressing modes other than DIRECT.
      return modrm_addressing_mode != ModRm::DIRECT &&
             // VSIB addressing is possible only with the SIB byte present. As
             // of 2018-05-25, we do not dive deeper into the variants of VSIB
             // addressing depending on the ModR/M addressing mode.
             modrm.rm_operand() == 4;
    case InstructionOperand::INDIRECT_ADDRESSING_WITH_INSTRUCTION_POINTER:
      return modrm_addressing_mode == ModRm::INDIRECT &&
             modrm.rm_operand() == 5;
    default:
      LOG(FATAL) << "Unsupported operand addressing mode: "
                 << InstructionOperand::AddressingMode_Name(
                        rm_operand_addressing_mode);
      break;
  }
  return false;
}

bool ModRmUsageMatchesSpecification(
    const EncodingSpecification& specification,
    const DecodedInstruction& decoded_instruction,
    const InstructionFormat& instruction_format) {
  switch (specification.modrm_usage()) {
    case EncodingSpecification::NO_MODRM_USAGE:
      break;
    case EncodingSpecification::FULL_MODRM:
      return AddressingModeMatchesSpecification(instruction_format,
                                                decoded_instruction);
    case EncodingSpecification::OPCODE_EXTENSION_IN_MODRM:
      if (decoded_instruction.modrm().register_operand() !=
          specification.modrm_opcode_extension()) {
        DVLOG(1) << "Opcode extension mismatch!\n"
                 << "Expected:" << specification.modrm_opcode_extension()
                 << "\nActual:"
                 << decoded_instruction.modrm().register_operand();
        return false;
      }
      return AddressingModeMatchesSpecification(instruction_format,
                                                decoded_instruction);
    default:
      // The default case is needed because protoc adds "technical" entries to
      // the enum, e.g. for the number of items.
      LOG(FATAL) << "Unexpected ModR/M usage specification: "
                 << specification.modrm_usage();
      break;
  }
  return true;
}

bool PrefixesAndOpcodeMatchSpecification(
    const EncodingSpecification& specification,
    const DecodedInstruction& instruction) {
  // TODO(ondrasej): For instructions that use ocpode extension in ModR/M, also
  // compare the value of the opcode extension.
  if ((specification.opcode() != instruction.opcode()) &&
      // If opcodes are not equal, check whether opcode has any operand encoded.
      // If that's the case, recheck by clearing out the operand.
      (specification.operand_in_opcode() ==
           EncodingSpecification::NO_OPERAND_IN_OPCODE ||
       specification.opcode() != (instruction.opcode() & 0xFFFFFFF8))) {
    DVLOG(1) << "Opcode mismatch:\n"
             << "Specifcation: " << specification.opcode()
             << "\nInstruction: " << instruction.opcode();
    return false;
  }

  // Check that the prefixes of the instruction match the specification. For
  // instructions with a VEX/EVEX prefix, the situation is simple: both the
  // instruction and the specification will have the VEX prefix field set,
  // because it contains mandatory information.
  // The situation is more complex for legacy instructions, because most of the
  // legacy prefixes are optional and both the instruction and the specification
  // may have the legacy prefix fields empty.
  // We get out of this by checking for the VEX/EVEX prefix first - if there is
  // no VEX/EVEX prefix on the instruction, this is clearly a legacy
  // instruction, and all we need to do on the instruction side is to check that
  // it doesn't have a VEX/EVEX prefix.
  // TODO(ondrasej): Check whether the choice between VEX and EVEX matters when
  // an instruction uses features that are supported by both, and allow the
  // loose matching if it does not. For now, we require that the instruction and
  // the specification use the same encoding.
  if (specification.has_vex_prefix()) {
    const VexPrefixEncodingSpecification& vex_prefix_specification =
        specification.vex_prefix();
    switch (vex_prefix_specification.prefix_type()) {
      case EVEX_PREFIX:
        if (!instruction.has_evex_prefix() ||
            !EvexPrefixMatchesSpecification(specification.vex_prefix(),
                                            instruction.evex_prefix())) {
          DVLOG(1) << "EVEX prefix mismatch!";
          return false;
        }
        break;
      case VEX_PREFIX:
        if (!instruction.has_vex_prefix() ||
            !VexPrefixMatchesSpecification(specification.vex_prefix(),
                                           instruction.vex_prefix())) {
          DVLOG(1) << "VEX prefix mismatch!";
          return false;
        }
        break;
      default:
        // NOTE(ondrasej): The default case covers only the sentinel values
        // created by the proto compiler.
        LOG(FATAL) << "Invalid prefix type!";
        break;
    }
  } else if (instruction.has_vex_prefix() || instruction.has_evex_prefix() ||
             !LegacyPrefixesMatchSpecification(specification.legacy_prefixes(),
                                               instruction)) {
    DVLOG(1) << "Legacy prefix mismatch!";
    return false;
  }
  return true;
}

const RegisterIndex kInvalidRegisterIndex(-1);

namespace {

const std::pair<RegisterIndex, std::initializer_list<const char*>>
    kRegisters[] = {
        {RegisterIndex(0), {"al", "ax", "eax", "rax", "es", "cr0", "dr0"}},
        {RegisterIndex(1), {"cl", "cx", "ecx", "rcx", "cs", "dr1"}},
        {RegisterIndex(2), {"dl", "dx", "edx", "rdx", "ss", "cr2", "dr2"}},
        {RegisterIndex(3), {"bl", "bx", "ebx", "rbx", "ds", "cr3", "dr3"}},
        {RegisterIndex(4), {"ah", "spl", "sp", "esp", "rsp", "fs", "cr4"}},
        {RegisterIndex(5), {"ch", "bpl", "bp", "ebp", "rbp", "gs"}},
        {RegisterIndex(6), {"dh", "sil", "si", "esi", "rsi", "dr6"}},
        {RegisterIndex(7), {"bh", "dil", "di", "edi", "rdi", "dr7"}},
        {RegisterIndex(8), {"cr8"}}};

const RegisterIndex kMaxX86LegacyRegisterIndex(7);
const RegisterIndex kMaxX86GeneralPurposeRegisterIndex(15);
const RegisterIndex kMaxX86RegisterIndex(31);

void AddRegisterBasedOnIndex(
    RegisterIndex index, absl::string_view name_base,
    absl::flat_hash_map<std::string, RegisterIndex>* register_list) {
  CHECK(register_list != nullptr);
  const std::string register_name = absl::StrCat(name_base, index.value());
  (*register_list)[register_name] = index;
}

absl::flat_hash_map<std::string, RegisterIndex>* MakeRegisterList() {
  auto register_list =
      absl::make_unique<absl::flat_hash_map<std::string, RegisterIndex>>();
  // Add the regsiters with names based on their index.
  for (RegisterIndex current_register_index(0);
       current_register_index < kMaxX86RegisterIndex;
       ++current_register_index) {
    if (current_register_index <= kMaxX86LegacyRegisterIndex) {
      AddRegisterBasedOnIndex(current_register_index, "st",
                              register_list.get());
      AddRegisterBasedOnIndex(current_register_index, "mm",
                              register_list.get());
    }
    if (current_register_index <= kMaxX86GeneralPurposeRegisterIndex) {
      AddRegisterBasedOnIndex(current_register_index, "r", register_list.get());
      AddRegisterBasedOnIndex(current_register_index, "xmm",
                              register_list.get());
      AddRegisterBasedOnIndex(current_register_index, "ymm",
                              register_list.get());
    }
    AddRegisterBasedOnIndex(current_register_index, "zmm", register_list.get());
  }

  // Add the registers with special names.
  for (const auto& registers : kRegisters) {
    const RegisterIndex current_register_index = registers.first;
    const std::initializer_list<const char*>& register_names = registers.second;
    for (const char* const register_name : register_names) {
      (*register_list)[register_name] = current_register_index;
    }
  }
  return register_list.release();
}

absl::flat_hash_map<std::string, RegisterIndex>* const kX86Registers =
    MakeRegisterList();

}  // namespace

RegisterIndex GetRegisterIndex(std::string register_name) {
  absl::AsciiStrToLower(&register_name);
  return ::exegesis::gtl::FindWithDefault(*kX86Registers, register_name,
                                          kInvalidRegisterIndex);
}

namespace {

// Stores 'register_index' in the modrm.reg bits and the corresponding extension
// bit of the REX or VEX prefix of 'instruction'.
// Operand indices were limited to 3 bits in the original x86 binary encoding;
// x86-64 increases the nunber of operands by allowing one additional bit for
// each operand index. These bits can't be added to the ModR/M byte without
// breaking backward compatibility, so they are stored in a REX or VEX prefix of
// the instruction. If the instrucion does not have such prefix, the value of
// the extension bits is fixed to zero. For more details on the encoding see
// http://wiki.osdev.org/X86-64_Instruction_Encoding.
inline void SetModRmRegOperand(RegisterIndex register_index,
                               DecodedInstruction* instruction) {
  DCHECK(instruction != nullptr);
  DCHECK_GE(register_index, 0);
  DCHECK_LE(register_index, kMaxX86RegisterIndex);
  ModRm* const modrm = instruction->mutable_modrm();
  modrm->set_register_operand(GetBitRange(register_index.value(), 0, 3));
  const bool uses_extension_bit = register_index > kMaxX86LegacyRegisterIndex;
  if (instruction->has_vex_prefix()) {
    instruction->mutable_vex_prefix()->set_not_r(!uses_extension_bit);
  } else {
    instruction->mutable_legacy_prefixes()->mutable_rex()->set_r(
        uses_extension_bit);
  }
}

// Stores 'register_index' in the modrm.rm bits of the corresponding extension
// bit of the REX or VEX prefix of 'instruction'. Preserves the ModR/M
// addressing mode and the SIB byte even if they are not valid with the new
// value of the modrm.rm bits.
inline void SetModRmRmValue(RegisterIndex register_index,
                            DecodedInstruction* instruction) {
  DCHECK(instruction != nullptr);
  DCHECK_GE(register_index, 0);
  DCHECK_LE(register_index, kMaxX86RegisterIndex);
  ModRm* const modrm = instruction->mutable_modrm();
  modrm->set_rm_operand(GetBitRange(register_index.value(), 0, 3));
  const bool uses_extension_bit = register_index > kMaxX86LegacyRegisterIndex;
  if (instruction->has_vex_prefix()) {
    instruction->mutable_vex_prefix()->set_not_b(!uses_extension_bit);
  } else {
    instruction->mutable_legacy_prefixes()->mutable_rex()->set_b(
        uses_extension_bit);
  }
}

// Stores 'register_index' in the modrm.rm bits and the corresponding extension
// bit of the REX or VEX prefix of 'instruction'. Changes the ModR/M addressing
// mode to direct addressing and clears the SIB byte.
inline void SetModRmRmOperandToRegister(RegisterIndex register_index,
                                        DecodedInstruction* instruction) {
  DCHECK(instruction != nullptr);
  DCHECK_GE(register_index, 0);
  DCHECK_LE(register_index, kMaxX86RegisterIndex);
  ModRm* const modrm = instruction->mutable_modrm();
  modrm->set_addressing_mode(ModRm::DIRECT);
  instruction->clear_sib();
  SetModRmRmValue(register_index, instruction);
}

// Stores 'register_index' in the operand bits of the instruction, if the
// instruction uses operands encoded in the opcode.
inline void SetOpcodeOperand(RegisterIndex register_index,
                             DecodedInstruction* instruction) {
  DCHECK(instruction != nullptr);
  DCHECK_GE(register_index, 0);
  DCHECK_LE(register_index, kMaxX86LegacyRegisterIndex);
  // The opcode-based operand is always encoded in the three least-significant
  // bits of the opcode. We create the new opcode by cleaning whatever their
  // previous value was, and by putting the new value in there.
  const uint32_t base_opcode = ClearBitRange(instruction->opcode(), 0, 3);
  instruction->set_opcode(base_opcode + register_index.value());
}

// Stores 'register_index' in the sib.base bits and the corresponding extension
// bit of the REX or VEX prefix of 'instruction'.
inline void SetSibBaseValue(RegisterIndex register_index,
                            DecodedInstruction* instruction) {
  DCHECK(instruction != nullptr);
  DCHECK_GE(register_index, 0);
  DCHECK_LE(register_index, kMaxX86GeneralPurposeRegisterIndex);
  Sib* const sib = instruction->mutable_sib();
  sib->set_base(GetBitRange(register_index.value(), 0, 3));
  const bool uses_extension_bit = register_index > kMaxX86LegacyRegisterIndex;
  if (instruction->has_vex_prefix()) {
    instruction->mutable_vex_prefix()->set_not_b(!uses_extension_bit);
  } else {
    instruction->mutable_legacy_prefixes()->mutable_rex()->set_b(
        uses_extension_bit);
  }
}

// Stores 'register_index' in the sib.index bits and the corresponding extension
// bit of the REX or VEX prefix of 'instruction'.
inline void SetSibIndexValue(RegisterIndex register_index,
                             DecodedInstruction* instruction) {
  DCHECK(instruction != nullptr);
  DCHECK_GE(register_index, 0);
  DCHECK_LE(register_index, kMaxX86GeneralPurposeRegisterIndex);
  Sib* const sib = instruction->mutable_sib();
  sib->set_index(GetBitRange(register_index.value(), 0, 3));
  const bool uses_extension_bit = register_index > kMaxX86LegacyRegisterIndex;
  if (instruction->has_vex_prefix()) {
    instruction->mutable_vex_prefix()->set_not_x(!uses_extension_bit);
  } else {
    instruction->mutable_legacy_prefixes()->mutable_rex()->set_x(
        uses_extension_bit);
  }
}

// Stores 'register_index' in the VEX prefix operand bits of 'instruction'. The
// bit inversion is done by the function.
inline void SetVexPrefixOperand(RegisterIndex register_index,
                                DecodedInstruction* instruction) {
  DCHECK(instruction != nullptr);
  DCHECK_GE(register_index, 0);
  DCHECK_LE(register_index, kMaxX86GeneralPurposeRegisterIndex);
  const uint32_t inverted_register_index =
      GetBitRange(~register_index.value(), 0, 4);
  instruction->mutable_vex_prefix()->set_inverted_register_operand(
      inverted_register_index);
}

// Stores 'register_index' in the VEX suffix operand bits of 'instruction'.
inline void SetVexSuffixOperand(RegisterIndex register_index,
                                DecodedInstruction* instruction) {
  DCHECK(instruction != nullptr);
  DCHECK_GE(register_index, 0);
  DCHECK_LE(register_index, kMaxX86GeneralPurposeRegisterIndex);
  // TODO(ondrasej): Investigate if there is something else that needs to be
  // done about the register.
  instruction->mutable_vex_prefix()->set_vex_suffix_value(register_index.value()
                                                          << 4);
}

}  // namespace

Status SetOperandToRegister(const InstructionFormat& instruction_format,
                            int operand_position, RegisterIndex register_index,
                            DecodedInstruction* instruction) {
  CHECK(instruction != nullptr);
  if (operand_position < 0 ||
      operand_position >= instruction_format.operands_size()) {
    return InvalidArgumentError(
        absl::StrCat("Invalid operand position: ", operand_position));
  }
  if (register_index < 0 || register_index > kMaxX86RegisterIndex) {
    return InvalidArgumentError(
        absl::StrCat("Invalid register index: ", register_index.value()));
  }

  const InstructionOperand& operand =
      instruction_format.operands(operand_position);
  const InstructionOperand::Encoding operand_encoding = operand.encoding();
  switch (operand_encoding) {
    case InstructionOperand::OPCODE_ENCODING:
      if (register_index > kMaxX86LegacyRegisterIndex) {
        return InvalidArgumentError(
            absl::StrCat("Only legacy registers can be encoded in the opcode. "
                         "Register index: ",
                         register_index.value()));
      }
      SetOpcodeOperand(register_index, instruction);
      break;
    case InstructionOperand::MODRM_REG_ENCODING:
      SetModRmRegOperand(register_index, instruction);
      break;
    case InstructionOperand::MODRM_RM_ENCODING:
      SetModRmRmOperandToRegister(register_index, instruction);
      break;
    case InstructionOperand::VEX_V_ENCODING:
      SetVexPrefixOperand(register_index, instruction);
      break;
    case InstructionOperand::VEX_SUFFIX_ENCODING:
      SetVexSuffixOperand(register_index, instruction);
      break;
    case InstructionOperand::IMPLICIT_ENCODING:
    case InstructionOperand::IMMEDIATE_VALUE_ENCODING:
      return InvalidArgumentError(
          absl::StrCat("Operands of type ",
                       InstructionOperand::Encoding_Name(operand_encoding),
                       " can't be assigned."));
    default:
      // The default case is there only to handle the entries automatically
      // generated by the proto compiler, such as the entries for the minimal
      // and the maximal values of the enumeration.
      LOG(FATAL) << "Unexpected operand encoding: "
                 << InstructionOperand::Encoding_Name(operand_encoding);
  }

  return OkStatus();
}

namespace {

// The value returned by GetMemoryOperandPosition when no matching operand is
// found. This value can never be the position of an existing operand.
constexpr int kInvalidOperandPosition = -1;

// Returns the position of the operand of an instruction which can use indirect
// addressing that is not an implicit/implicitly-encoded operand. In x86-64
// there is at most one such argument, because only the modrm.rm operand allows
// indirect addressing. The function returns the position of such operand, i.e.
// an operand that:
//  1. is encoded using the modrm.rm bits,
//  2. allows indirect addressing per the instruction set specification.
// Note that this function does ignore operands that use the implicit encoding
// for indirect addressing through the RDI and RSI registers. They accept memory
// locations, but the registers used for the addressing are fixed by the
// specification and there is no way to change them.
int GetMemoryOperandPosition(const InstructionFormat& instruction_format) {
  for (int position = 0; position < instruction_format.operands_size();
       ++position) {
    const InstructionOperand& operand = instruction_format.operands(position);
    // The addressing mode of the operand may be either a generic category that
    // includes INDIRECT_ADDRESSING as a sub-category, or it might be one of the
    // concrete values in the INDIRECT_ADDRESSING category.
    const bool allows_indirect_addressing =
        InCategory(InstructionOperand::INDIRECT_ADDRESSING,
                   operand.addressing_mode()) ||
        InCategory(operand.addressing_mode(),
                   InstructionOperand::INDIRECT_ADDRESSING);
    if (allows_indirect_addressing &&
        operand.encoding() == InstructionOperand::MODRM_RM_ENCODING) {
      return position;
    }
  }
  return kInvalidOperandPosition;
}

bool HasMemoryOperand(const InstructionFormat& instruction_format) {
  return GetMemoryOperandPosition(instruction_format) !=
         kInvalidOperandPosition;
}

}  // namespace

#define RETURN_ERROR_IF_NO_MEMORY_OPERAND(instruction_format)         \
  if (!HasMemoryOperand(instruction_format)) {                        \
    return InvalidArgumentError(                                      \
        "The instruction does not have an explicit memory operand."); \
  }
#define RETURN_ERROR_IF_OUT_OF_RANGE(register_index, min_value, max_value) \
  if ((register_index) < (min_value) || (register_index) > (max_value)) {  \
    return InvalidArgumentError("The instruction index is out of range."); \
  }

Status SetOperandToMemoryAbsolute(const InstructionFormat& instruction_format,
                                  uint32_t absolute_address,
                                  DecodedInstruction* instruction) {
  CHECK(instruction != nullptr);
  RETURN_ERROR_IF_NO_MEMORY_OPERAND(instruction_format);
  // The escape values used for the absolute addressing by absolute address
  // encoded in the instruction.
  constexpr RegisterIndex kModRmRmRegisterIndex(4);
  constexpr RegisterIndex kSibBaseRegisterIndex(5);
  constexpr RegisterIndex kSibIndexRegisterIndex(4);

  ModRm* const modrm = instruction->mutable_modrm();
  modrm->set_addressing_mode(ModRm::INDIRECT);
  modrm->set_address_displacement(absolute_address);
  SetModRmRmValue(kModRmRmRegisterIndex, instruction);
  SetSibBaseValue(kSibBaseRegisterIndex, instruction);
  SetSibIndexValue(kSibIndexRegisterIndex, instruction);
  return OkStatus();
}

Status SetOperandToMemoryBase(const InstructionFormat& instruction_format,
                              RegisterIndex base_register,
                              DecodedInstruction* instruction) {
  CHECK(instruction != nullptr);
  RETURN_ERROR_IF_NO_MEMORY_OPERAND(instruction_format);
  RETURN_ERROR_IF_OUT_OF_RANGE(base_register, 0,
                               kMaxX86GeneralPurposeRegisterIndex);
  const int base_register_base_bits = base_register.value() & 7;
  if (base_register_base_bits == 4 || base_register_base_bits == 5) {
    return InvalidArgumentError(
        "Register indices 4, 5, 12, and 13 cannot be encoded using only "
        "the ModR/M byte.");
  }
  ModRm* const modrm = instruction->mutable_modrm();
  modrm->set_addressing_mode(ModRm::INDIRECT);
  instruction->clear_sib();
  SetModRmRmValue(base_register, instruction);
  return OkStatus();
}

Status SetOperandToMemoryBaseSib(const InstructionFormat& instruction_format,
                                 RegisterIndex base_register,
                                 DecodedInstruction* instruction) {
  CHECK(instruction != nullptr);
  RETURN_ERROR_IF_NO_MEMORY_OPERAND(instruction_format);
  RETURN_ERROR_IF_OUT_OF_RANGE(base_register, 0,
                               kMaxX86GeneralPurposeRegisterIndex);
  // The register indices used as escape values for the SIB byte and the
  // indirect addressing with only the base register.
  constexpr RegisterIndex kModRmRmRegisterIndex(4);
  constexpr RegisterIndex kSibIndexRegisterIndex(4);
  // sib.base == 5 serves as an escape value for indirect addressing with an
  // absolute address.
  if (base_register == 5 || base_register == 13) {
    return InvalidArgumentError(
        "Register indices 5 and 13 cannot be used as base register when "
        "encoding the address with the SIB byte.");
  }
  ModRm* const modrm = instruction->mutable_modrm();
  modrm->set_addressing_mode(ModRm::INDIRECT);
  SetModRmRmValue(kModRmRmRegisterIndex, instruction);
  SetSibBaseValue(base_register, instruction);
  SetSibIndexValue(kSibIndexRegisterIndex, instruction);
  instruction->mutable_sib()->set_scale(0);
  return OkStatus();
}

Status SetOperandToMemoryRelativeToRip(
    const InstructionFormat& instruction_format, int32_t displacement,
    DecodedInstruction* instruction) {
  CHECK(instruction != nullptr);
  RETURN_ERROR_IF_NO_MEMORY_OPERAND(instruction_format);
  constexpr RegisterIndex kRipRelativeAddressingRegisterIndex(5);
  ModRm* const modrm = instruction->mutable_modrm();
  modrm->set_addressing_mode(ModRm::INDIRECT);
  SetModRmRmValue(kRipRelativeAddressingRegisterIndex, instruction);
  modrm->set_address_displacement(static_cast<uint32_t>(displacement));
  instruction->clear_sib();
  return OkStatus();
}

template <typename DisplacementType>
Status SetOperandToMemoryBaseAndDisplacement(
    const InstructionFormat& instruction_format, RegisterIndex base_register,
    DisplacementType displacement, DecodedInstruction* instruction) {
  CHECK(instruction != nullptr);
  RETURN_ERROR_IF_NO_MEMORY_OPERAND(instruction_format);
  RETURN_ERROR_IF_OUT_OF_RANGE(base_register, 0,
                               kMaxX86GeneralPurposeRegisterIndex);
  static_assert(std::is_signed<DisplacementType>::value,
                "DisplacementType is not a signed type.");
  using UnsignedDisplacementType =
      typename std::make_unsigned<DisplacementType>::type;

  if (base_register == 4 || base_register == 12) {
    return InvalidArgumentError(
        "Register indices 4 and 12 cannot be encoded using only the ModR/M "
        "byte.");
  }
  ModRm* const modrm = instruction->mutable_modrm();
  constexpr ModRm::AddressingMode addressing_mode =
      sizeof(DisplacementType) == sizeof(int8_t)
          ? ModRm::INDIRECT_WITH_8_BIT_DISPLACEMENT
          : ModRm::INDIRECT_WITH_32_BIT_DISPLACEMENT;
  modrm->set_addressing_mode(addressing_mode);
  // We need to convert the displacement to 8-bit unsigned char to be sure that
  // it's not sign-extended to a negative 32-bit number.
  modrm->set_address_displacement(
      static_cast<UnsignedDisplacementType>(displacement));
  instruction->clear_sib();
  SetModRmRmValue(base_register, instruction);

  return OkStatus();
}

// Explicitly instantiate the template function for int8_t and int32_t (the only
// types supported by the x86 and x86-64 instruction encoding).
Status SetOperandToMemoryBaseAnd8BitDisplacement(
    const InstructionFormat& instruction_format, RegisterIndex base_register,
    int8_t displacement, DecodedInstruction* instruction) {
  return SetOperandToMemoryBaseAndDisplacement<int8_t>(
      instruction_format, base_register, displacement, instruction);
}

Status SetOperandToMemoryBaseAnd32BitDisplacement(
    const InstructionFormat& instruction_format, RegisterIndex base_register,
    int32_t displacement, DecodedInstruction* instruction) {
  return SetOperandToMemoryBaseAndDisplacement<int32_t>(
      instruction_format, base_register, displacement, instruction);
}

#undef RETURN_ERROR_IF_NO_MEMORY_OPERAND
#undef RETURN_ERROR_IF_OUT_OF_RANGE

}  // namespace x86
}  // namespace exegesis
