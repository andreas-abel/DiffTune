// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Contains functions for generating register definitions based on a template
// and a given collection of register names.

#ifndef EXEGESIS_BASE_REGISTERS_H_
#define EXEGESIS_BASE_REGISTERS_H_

#include <string>
#include <vector>

#include "exegesis/proto/registers.pb.h"

namespace exegesis {

// A template for generating registers in a group. For a base name, the register
// definition is generated by adding a prefix and a suffix to the name, by
// setting its position in the group to the given values, and by setting its
// binary encoding to a value computed as a combination of a base value, the
// index of the base name, and the encoding offset specified in the template.
struct RegisterTemplate {
  // The prefix added to the base name.
  const char* prefix;

  // The suffix added to the base name.
  const char* suffix;

  // The index of the least significant bit of the register in the register
  // group.
  int lsb;

  // The index of the most significant bit of the register in the register
  // group.
  int msb;

  // The value added to the binary encoding of the register associated with the
  // register group. Note that in most cases, all registers in one register
  // group have the same binary encoding, and their encoding_offset is zero.
  // However, the x86-64 registers AH, BH, CH and DH can't use the same binary
  // encoding as the other registers in their groups, because they are already
  // used by registers AL, BL, CL and DL. To avoid the conflict, the binary
  // encoding of the register xH is the binary encoding of xL + 4.
  int encoding_offset;

  // The name of the feature that makes the register available.
  const char* feature_name;

  // The class of the registers.
  RegisterProto::RegisterClass register_class;
};

// Creates a RegisterSetProto from the given templates and a set of base names.
// The function creates one group for each base name, and each group will
// contain one register for each template. The register for i-th base name and
// template tpl is created as follows:
//   name: tpl.prefix + base_names[i] + tpl.suffix
//   position_in_group { lsb: tpl.lsb
//                       msb: tpl.msb }
//   binary_encoding: base_binary_encoding + i + tpl.encoding_offset
// The name and description of each group are generated from the name of the
// first register in the group.
RegisterSetProto MakeRegistersFromBaseNames(
    const std::vector<RegisterTemplate>& templates,
    const std::vector<std::string>& base_names, int base_binary_encoding);

// Creates a RegisterSetProto from the given templates, a base name, and a range
// of indices. The function creates one group for each index in the range, and
// each group will contain one register for each template. The register for
// index i and template tpl is created as follows:
//   name: tpl.prefix + base_name + string(i) + tpl.suffix
//   position_in_group { lsb: tpl.lsb
//                       msb: tpl.msb }
//   binary_encoding: base_binary_encoding + i + tpl.encoding_offset
// The name and the description of each group are generated from the name of the
// first register in the group. Note that begin_index is inclusive, and
// end_index is exclusive.
RegisterSetProto MakeRegistersFromBaseNameAndIndices(
    const std::vector<RegisterTemplate>& templates,
    const std::string& base_name, int begin_index, int end_index,
    int base_binary_encoding);

}  // namespace exegesis

#endif  // EXEGESIS_BASE_REGISTERS_H_
